# bot.py (–≤—Å—Ç–∞–≤—å—Ç–µ —Å—é–¥–∞ –∫–æ–¥ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è)
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler,
    CallbackQueryHandler, ContextTypes, filters
)
import database  # –≤–∞—à —Ñ–∞–π–ª database.py

# –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ —Å–≤–æ–π —Ç–æ–∫–µ–Ω –∏ ID –∞–¥–º–∏–Ω–∞
TOKEN = '7368248796:AAEaCqJv63V9a0Rz_yRuqLADRpjkjLpGfDM'
ADMIN_ID = 5930123472  # –∑–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π Telegram user_id –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

logger = logging.getLogger(__name__)

# –ö–æ–º–∞–Ω–¥–∞ /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("–ü—Ä–∏–≤–µ—Ç! –û—Ç–ø—Ä–∞–≤—å —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å, –∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä —Å–∫–æ—Ä–æ –æ—Ç–≤–µ—Ç–∏—Ç.")

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    text = update.message.text

    # –ï—Å–ª–∏ —ç—Ç–æ –∞–¥–º–∏–Ω ‚Äî –ø—Ä–æ–≤–µ—Ä—è–µ–º, –æ–∂–∏–¥–∞–µ—Ç—Å—è –ª–∏ –æ—Ç –Ω–µ–≥–æ –æ—Ç–≤–µ—Ç
    if user_id == ADMIN_ID:
        pending_question_id = database.get_admin_pending_response(user_id)
        if pending_question_id:
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ç–≤–µ—Ç –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
            question_data = database.get_question_by_id(pending_question_id)
            if question_data:
                question_id, target_user_id, _ = question_data
                database.save_answer(question_id, text)
                database.clear_admin_pending_response(user_id)
                try:
                    await context.bot.send_message(chat_id=target_user_id, text=f'üí¨ –û—Ç–≤–µ—Ç –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:\n{text}')
                    await update.message.reply_text("‚úÖ –û—Ç–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é.")
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ç–≤–µ—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é: {e}")
                    await update.message.reply_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é.")
            return

    # –ï—Å–ª–∏ —ç—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å, —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤–æ–ø—Ä–æ—Å –∏ —É–≤–µ–¥–æ–º–ª—è–µ–º –∞–¥–º–∏–Ω–∞
    question_id = database.add_question(user_id, text)
    await update.message.reply_text("‚úÖ –í–æ–ø—Ä–æ—Å –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
    keyboard = InlineKeyboardMarkup([[
        InlineKeyboardButton("‚úèÔ∏è –û—Ç–≤–µ—Ç–∏—Ç—å", callback_data=f"reply_{question_id}")
    ]])
    await context.bot.send_message(
        chat_id=ADMIN_ID,
        text=f'üì© –ù–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å #{question_id} –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}:\n{text}',
        reply_markup=keyboard
    )

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–∫–∏ "–û—Ç–≤–µ—Ç–∏—Ç—å"
async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data

    if data.startswith("reply_"):
        question_id = int(data.split("_")[1])
        database.save_admin_pending_response(query.from_user.id, question_id)
        await query.message.reply_text(f"‚úèÔ∏è –í–≤–µ–¥–∏ –æ—Ç–≤–µ—Ç –Ω–∞ –≤–æ–ø—Ä–æ—Å #{question_id}:")

# –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –≤—Å–µ—Ö –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤ (–ø–æ –∂–µ–ª–∞–Ω–∏—é)
async def list_questions(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("‚õîÔ∏è –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤.")
        return

    questions = database.get_pending_questions()
    if not questions:
        await update.message.reply_text("‚úÖ –ù–µ—Ç –Ω–æ–≤—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤.")
        return

    for q in questions:
        question_id, user_id, question_text = q
        keyboard = InlineKeyboardMarkup([[
            InlineKeyboardButton("‚úèÔ∏è –û—Ç–≤–µ—Ç–∏—Ç—å", callback_data=f"reply_{question_id}")
        ]])
        await update.message.reply_text(
            f"üì® –í–æ–ø—Ä–æ—Å #{question_id} –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}:\n{question_text}",
            reply_markup=keyboard
        )

# –ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞
async def main():
    database.init_db()

    application = ApplicationBuilder().token(TOKEN).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("list", list_questions))
    application.add_handler(CallbackQueryHandler(button_callback))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    logging.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω")
    await application.run_polling()

# –ó–∞–ø—É—Å–∫
if __name__ == '__main__':
    import asyncio
    try:
        asyncio.run(main())
    except RuntimeError:
        import nest_asyncio
        nest_asyncio.apply()
        asyncio.get_event_loop().run_until_complete(main())
